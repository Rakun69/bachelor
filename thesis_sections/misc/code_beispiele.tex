% Code-Beispiele: verschiedene Darstellungsvarianten
\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage[table]{xcolor}
\usepackage{xurl}
\usepackage{listings}
\usepackage[most]{tcolorbox}
\tcbuselibrary{listings,skins}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{array}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Flex-Spalte für Tabularx
\newcolumntype{Y}{>{\raggedright\arraybackslash}X}

% Einheitlicher Stil für Listings
\lstdefinestyle{codeblock}{%
  basicstyle=\ttfamily\small,
  breaklines=true,
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false,
  frame=single,
  framerule=0.5pt,
  backgroundcolor=\color[gray]{0.96},
  keywordstyle=\color{blue!70!black}\bfseries,
  commentstyle=\color{green!40!black}\itshape,
  stringstyle=\color{orange!70!black},
  numbers=left,
  numberstyle=\tiny,
  numbersep=14pt,
  xleftmargin=2.4em,
  framexleftmargin=1.8em
}
\lstset{style=codeblock}

% Farbige Code-Boxen (Info/Erfolg/Warnung)
\newtcblisting{codeinfo}{enhanced,breakable,listing only,listing options={style=codeblock},
  colback=blue!4,colframe=blue!55!black,title={Info},boxrule=0.6pt}
\newtcblisting{codesuccess}{enhanced,breakable,listing only,listing options={style=codeblock},
  colback=green!5,colframe=green!50!black,title={Success},boxrule=0.6pt}
\newtcblisting{codewarn}{enhanced,breakable,listing only,listing options={style=codeblock},
  colback=orange!6,colframe=orange!65!black,title={Warning},boxrule=0.6pt}

\title{Code-Beispiele: Darstellungsvarianten}
\author{Demo}
\date{\today}

\begin{document}
\maketitle

\section{Inline und kurzer Block}
Inline-Befehl im Text: \texttt{zokrates compile -i circuits/basic/filter\_range.zok}.

Kurzer Block ohne Rahmen:
\begin{lstlisting}[frame=none,numbers=none]
zokrates compile -i circuits/basic/filter_range.zok -o filter_range.out
zokrates setup
zokrates compute-witness -a 42 0 100
zokrates generate-proof
\end{lstlisting}

\section{Frameder Code mit Hintergrund}
\begin{codesuccess}
python -m venv iot_zk_env && source iot_zk_env/bin/activate && pip install -r requirements.txt
bash build_zokrates_nova.sh
bash run_evaluation.sh --phase compile
\end{codesuccess}

\section{Nummerierte Schritte mit Snippets}
\begin{enumerate}
  \item Kompilieren
\begin{codeinfo}[listing only,numbers=none]
zokrates compile -i circuits/basic/min_max.zok
\end{codeinfo}
  \item Beweis erzeugen
\begin{codeinfo}[listing only,numbers=none]
zokrates generate-proof
\end{codeinfo}
  \item Verifizieren
\begin{codewarn}[listing only,numbers=none]
zokrates verify
\end{codewarn}
\end{enumerate}

\section{Zweispaltig: Code links, Erklärung rechts}
\noindent\begin{minipage}[t]{0.58\linewidth}
\begin{lstlisting}
def _prepare_circuit_inputs(readings, batch_size):
    filtered = [r for r in readings if 0 <= r <= 100]
    return [filtered[i:i+batch_size] for i in range(0, len(filtered), batch_size)]
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{0.38\linewidth}
\textbf{Erläuterung:} Beispielhafte Batching-Funktion (Python). Erst Filterung, dann Gruppen in Blöcke der Größe \emph{batch\_size}.
\end{minipage}

\section{Pseudocode mit algorithmicx}
\begin{algorithm}[H]
\caption{Systemauswahl in Abhängigkeit von Datenmenge und RAM}
\begin{algorithmic}[1]
\State \textbf{Input:} $n$ (Datenmenge), $M$ (RAM), $R$ (Echtzeitanforderung)
\If{$M < 10\,\text{MB}$}
  \State Wähle \textbf{Recursive SNARKs} (RAM-limitierte Umgebung)
\ElsIf{$n < 85$ \text{ and } $R = \text{hoch}$}
  \State Wähle \textbf{Standard SNARKs} (geringe Latenz)
\ElsIf{$85 \le n \le 171$}
  \State Fall-zu-Fall-Entscheidung (Speicher/Netz/Privacy)
\Else
  \State Wähle \textbf{Recursive SNARKs}
\EndIf
\end{algorithmic}
\end{algorithm}

\section{Hybrid: Pseudocode mit farbigem Info-Header}
\newtcolorbox{algwithnotes}[1][]{enhanced,breakable,sharp corners,boxrule=0.6pt,
  colback=blue!3,colframe=blue!55!black,title={#1},fonttitle=\bfseries}

\begin{algwithnotes}[Recursive vs. Standard Selection]
\textbf{Input:} {\color{blue!70!black}$n$ (items), $M$ (RAM in MB), $R$ (real-time)}\\
\textbf{Hint:} {\color{orange!80!black}Prefer recursion if memory is the bottleneck or $n>171$.}

\medskip
\begin{algorithmic}[1]
\State \textbf{Input:} $n$, $M$, $R$
\If{$M < 10\,\text{MB}$}
  \State Choose Recursive SNARKs (RAM constraint)
\ElsIf{$n < 85$ \text{ and } $R = \text{critical}$}
  \State Choose Standard SNARKs (low latency)
\ElsIf{$85 \le n \le 171$}
  \State Evaluate storage/network/privacy trade-offs
\Else
  \State Choose Recursive SNARKs
\EndIf
\end{algorithmic}

\medskip
\textbf{Command:} \texttt{bash run\_evaluation.sh --phase compile}
\end{algwithnotes}

\section{Lange Zeile mit automatischem Umbruch}
\begin{lstlisting}
python demo.py --input data/raw/iot_readings_1_month.json --batch-size 240 --prove recursive --export /home/ramon/bachelor/data/visualizations --log-level INFO
\end{lstlisting}

\end{document}


